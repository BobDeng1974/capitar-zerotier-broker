//
// Copyright 2018 Capitar IT Group BV <info@capitar.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include <stddef.h>
#include <stdint.h>

// Base32 implementation, needed for Oath.  This is specified by RFC 4648.
// The alphabet is compromised of groups of 5 bits at a time, and avoids
// letters that may be easily mistyped.

static uint8_t b32dec[256] = {
	// clang-format off
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
	0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
	0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	// clang-format on
};

static const char *b32enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

size_t
base32_decode(const char *in, size_t in_len, uint8_t *out, size_t out_len)
{
	// Decode in groups of 5 bits at a time.
	uint32_t val     = 0;
	int      nbb     = 0;
	size_t   out_idx = 0;

	for (int i = 0; i < in_len; i++) {
		uint8_t x = b32dec[in[i]];
		if (x > 0x1F) {
			if (x == '=') {
				// ignore padding.
				break;
			}
			return (0); // invalid decode
		}
		val <<= 5;
		val |= x;
		nbb += 5;
		if (nbb < 8) {
			continue;
		}
		nbb -= 8;
		if (out_idx < out_len) {
			out[out_idx] = (val >> nbb) & 0xff;
		}
		out_idx++;
		// NB: we leave the used bits in val, but they should
		// be harmless.
	}
	return (out_idx);
}

size_t
base32_encode(const uint8_t *in, size_t in_len, char *out, size_t out_len)
{
	uint32_t val     = 0;
	int      nbb     = 0;
	size_t   out_idx = 0;

	// For encoding, we break each value down.
	for (int i = 0; i < in_len; i++) {
		val <<= 8;
		val |= in[i];
		nbb += 8;
		while (nbb > 5) {
			nbb -= 5;
			if (out_idx < out_len) {
				out[out_idx] = b32enc[(val >> nbb) & 0x1f];
			}
			out_idx++;
		}
	}
	if (out_idx < out_len) {
		out[out_idx] = '\0'; // Terminate if possible.
	}
	return (out_idx);
}
